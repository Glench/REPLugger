<!DOCTYPE html>
<html lang="en-US" prefix="og: http://ogp.me/ns#">

    <head>
        <title></title>
        <style type="text/css">
            html, body {
                margin: 0;
                padding: 0;
                font-size: 13px;
                font-family: Helvetica, Arial, sans-serif;
                line-height: 1;
            }
            table {
                border-collapse: collapse;
                border-spacing: none;
            }
            p {
                margin: 0;
            }

            .CodeMirror {
                border: 1px solid #ccc;
            }
            .CodeMirror .CodeMirror-activeline-background {
                background-color: #ace0ff;
            }
            #main-editor {
                width: 60%;
                display: inline-block;
                vertical-align: top;
            }
            #main-editor .CodeMirror {
            }
            #sidebar {
                width: 36%;
                display: inline-block;
                font-family: Courier;
                vertical-align: top;
                padding: 5px;
            }
            #sidebar input {
                background-color: transparent;
                border: 0;
                width: 100%;
                font-family: Courier;
                font-size: 13px;
            }
            #sidebar h2 {
                background-color: #ace0ff;
                color: black;
                padding: 4px 10px;
            }
            #test {
                overflow: auto;
            }
            #sidebar #test {
                border: 1px solid #ddd;
            }
            #sidebar table {
                width: 100%;
                table-layout: auto;
            }
            #sidebar tbody td {
                padding: 3px 0;
            }
            #sidebar tbody tr:nth-child(odd) td {
               background-color: #eee;
            }
            #sidebar thead th {
                text-align: left;
                padding: 3px 5px;
                background-color: #d2d2d2;
                color: black;
                border-bottom: 1px solid #9e9e9e;
            }
            #sidebar tr:last-child td {
                border-bottom: 10px solid white;
            }
            #sidebar tbody td {
                padding-left: 5px;
            }
            #sidebar tbody td:nth-child(2) {
                padding-left: 10px;
                white-space: nowrap;
                width: 100%; /* makes sure this column takes up as much space as it can */
            }

            #sidebar #current-line {
                position: absolute;
                bottom: 0;
                background-color: white;
                width: 36%;
                padding-bottom: 20px;
            }
            #sidebar .current-line-expansion {
                font-size: 14px;
                white-space: nowrap;
            }
            #sidebar .interpreted-line div {
                display: inline-block;
                vertical-align: top;
            }
            #sidebar .interpreted-line div[data] {
                margin: 1px 0;
                background-color: #ddd;
                text-align: center;
                border: 1px solid #aaa;
                border-width: 0 1px;
                overflow: hidden;
                white-space: nowrap;
                overflow: auto;
            }
            #sidebar .interpreted-line div[data].hover,
            #sidebar .current-line span.hover
            {
                background-color: #8ee5ff;
            }

        </style>
        <link href="node_modules/codemirror/lib/codemirror.css" rel="stylesheet">
        <link href="node_modules/codemirror/addon/dialog/dialog.css" rel="stylesheet">

        <!--
        <meta name="twitter:card" content="summary" />
        <meta name="twitter:site" content="@glenchsite" />
        <meta name="twitter:creator" content="@glench" />
        <meta property="og:type" content="article" />
        <meta property="og:url" content="http://glench.com/DeepListeningAtTheRecurseCenter/" />
        <meta property="og:title" content="Deep Listening at the Recurse Center" />
        <meta property="og:description" content="Helping programmers become more self-directed through meditative listening." />
        <meta property="og:image" content="http://glench.com/DeepListeningAtTheRecurseCenter/icon.png" />
        -->

    </head>
    <body>
        <div id="main-editor"></div>

        <div id="sidebar">
            <div id="test">
            </div>

<!--             <table>
                <thead> <tr> <th colspan="2">file</th> </tr> </thead>

                <tbody>
                    <tr><td>const $</td><td>require('jquery');</td></tr>

                    <tr><td>const _</td><td>require('underscore');</td></tr>
                    <tr><td>const React</td><td>require('react');</td></tr>
                    <tr><td>const ReactDOM</td><td>require('react-dom');</td></tr>
                    <tr><td>const CodeMirror</td><td>require('codemirror');</td></tr>
                    <tr><td>const rows</td><td>300;</td></tr>
                    <tr><td>const columns</td><td>30;</td></tr>
                    <tr><td>const cell_width</td><td>88; // including borders</td></tr>
                    <tr><td>const cell_height</td><td>19; // including borders</td></tr>
                    <tr><td>clamp(3,1,2)</td><td>2</td></tr>

                    <tr><td>const visualizations</td><td>require('./visualizations')</td></tr>
                    <tr><td>const interpreter</td><td>require('./interpreter')</td></tr>
                    <tr><td>const Block</td><td>interpreter.Block;</td></tr>
                    <tr><td>const Import</td><td>interpreter.Import;</td></tr>
                    <tr><td>var ui_blocks: UIBlock[]</td><td>[];</td></tr>

                    <tr> <td>class UIBlock {</td><td>something</td></tr>

                    <tr><td>class Move_Drag {</td><td>something</td></tr>

                    <tr><td>class Resize_Drag {</td><td>something</td></tr>

                    <tr><td>class Resize_Code_Drag {</td><td>something</td></tr>

                    <tr><td>var resize_drag: ?Resize_Drag</td><td>null;</td></tr>
                    <tr><td>var move_drag: ?Move_Drag</td><td>null;</td></tr>
                    <tr><td>var resize_code_drag: ?Resize_Code_Drag</td><td>null;</td></tr>



                </tbody>

                <thead>
                    <tr>
                        <th colspan="2">function initialize_grid() {</th>
                    </tr>
                </thead>

                <tbody>
                    <tr> <td>var $main</td> <td>$('canvas#main')</td> </tr>
                    <tr> <td>var height</td> <td>rows*cell_height;</td> </tr>
                    <tr> <td>var width</td> <td>columns*cell_width;</td> </tr>
                    <tr> <td>var canvas</td> <td>$main.get(0)</td> </tr>
                    <tr> <td>var ctx</td> <td>canvas.getContext('2d');</td> </tr>
                    <tr> <td>row</td> <td>299</td> </tr>
                    <tr> <td>column</td> <td>29</td> </tr>
                </tbody>
                <thead>
                    <tr>
                        <th colspan="2">$('body').on('mousemove', function(evt) {</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td>evt</td><td>some thing</td></tr>
                    <tr><td>var ui_block</td><td>resize_drag.ui_block;</td></tr>
                    <tr><td>var dx</td><td>evt.pageX - resize_drag.x;</td></tr>
                    <tr><td>var dy</td><td>evt.pageY - resize_drag.y;</td></tr>
                    <tr><td>var new_columns</td><td>Math.floor(dx/cell_width);</td></tr>
                    <tr><td>var new_rows</td><td>Math.floor(dy/cell_height);</td></tr>
                    <tr><td>var previous_output_height</td><td>ui_block.output_height;</td></tr>
                </tbody>
            </table>
 -->
            <div id="current-line">
                <h2></h2>
                <div class="current-line-expansion"></div>
                <div class="interpreted-line"></div>
            </div>

        </div>

        <script src="node_modules/jquery/dist/jquery.js"></script>
        <script src="node_modules/underscore/underscore.js"></script>
        <script src="node_modules/codemirror/lib/codemirror.js"></script>
        <script src="node_modules/codemirror/mode/javascript/javascript.js"></script>
        <script src="node_modules/codemirror/addon/selection/active-line.js"></script>
        <script src="node_modules/codemirror/addon/edit/matchbrackets.js"></script>
        <script src="node_modules/codemirror/addon/search/searchcursor.js"></script>
        <script src="node_modules/codemirror/addon/dialog/dialog.js"></script>
        <script src="node_modules/codemirror/keymap/vim.js"></script>
        <script src="node_modules/flow-parser/flow_parser.js" charset="utf-8"></script>
        <script type="text/javascript">

            const $ = require('jquery');
            const fs = require('fs');
            const React = require('react');
            const ReactDOM = require('react-dom');
            const CircularJSON = require('circular-json');
            const flowRemoveTypes = require('flow-remove-types');
            const { spawnSync } = require('child_process');


            function evalInContext(scr, context) {
                // execute script in private context
                return (new Function( "with(this) { return " + scr + "}")).call(context);
            }


            var current_line_number = 120; // 1-based
            var variable_overrides = {} // key: line number, value: {} key: name, value: line to run
            var scope_values = {}; // values of all variables in different scopes returned from mock environment


            class Value extends React.Component {
                constructor(props) {
                    super(props);
                    this.state = {editing: false, value: value_to_string(props.value)}
                    this.edit = this.edit.bind(this);
                    this.change = this.change.bind(this);
                    this.blur = this.blur.bind(this);
                    this.keydown = this.keydown.bind(this);
                }
                change(evt) {
                    this.setState({value: evt.target.value})
                }
                edit(evt) {
                    this.setState({editing: true})
                }
                blur(evt) {
                    if (!variable_overrides[current_line_number]) {
                        variable_overrides[current_line_number] = {}
                    }
                    this.setState({editing: false})
                    variable_overrides[current_line_number][this.props.name] = evt.target.value;
                    run_and_render();
                }
                keydown(evt) {
                    if (evt.which == 13) {
                        if (!variable_overrides[current_line_number]) {
                            variable_overrides[current_line_number] = {}
                        }
                        this.setState({editing: false})
                        variable_overrides[current_line_number][this.props.name] = evt.target.value;
                        run_and_render();
                    }
                }
                render() {
                    return React.createElement('input', {
                        value: this.state.value,
                        readOnly: !this.state.editing,
                        onChange: this.change,
                        onDoubleClick: this.edit,
                        // onBlur: this.blur,
                        onKeyDown: this.keydown,
                    })
                }
            }
            class ScopeTable extends React.Component {
                update_height() {
                    setTimeout(function() {
                        $('#test').height($(window).height() - $('#current-line').height()-50).scrollTop(100000)
                    }, 300)
                }
                componentDidUpdate() {
                    this.update_height();
                }
                componentDidMount() {
                    this.update_height();
                }
                render() {
                    return React.createElement('table', null, this.props.scopes.map(scope => {
                        scope.names_in_scope.sort();
                        return [React.createElement('thead', {key: scope.name},
                            React.createElement('tr', null,
                                React.createElement('th', {colSpan: 2}, scope.name)
                            )
                        ),
                        React.createElement('tbody', {key: scope.name+' body'},
                            scope.names_in_scope.map(name => {
                                return React.createElement('tr', {key: name}, [
                                    React.createElement('td', {key: name+' name'}, name),
                                    React.createElement('td', {key: name+' value'}, React.createElement(Value, {name: name, value: this.props.values[name]})),
                                ])
                            })
                        )
                        ]
                    }));
                }
            }

            main_editor = CodeMirror(document.querySelector('#main-editor'), {
                value: fs.readFileSync('/Users/glen/code/flowsheets2/src/renderer.js', 'utf-8').toString(),
                mode: 'javascript',
                lineNumbers: true,
                styleActiveLine: true,
                indentUnit: 4,
                keyMap: 'vim',
                matchBrackets: true,
                showCursorWhenSelecting: true,
                inputStyle: 'contenteditable',
            });
            CodeMirror.Vim.map('jj', '<Esc>', 'insert')

            $('.CodeMirror').height($(window).height())
            main_editor.setCursor({line: current_line_number, ch: 20})
            main_editor.refresh()

            main_editor.on('cursorActivity', cursor_activity);
            cursor_activity(main_editor)



            function run_and_render() {
                const source = main_editor.getValue();
                const ast_before_current_line = flow.parse(source.split('\n').slice(0, current_line_number).join('\n'));
                console.log('ast up to current line', ast_before_current_line)
                const scopes = ast_to_list_of_scopes(ast_before_current_line, 'file', current_line_number, source, [])

                var mock_js = ast_node_to_js(ast_before_current_line, scopes);
                console.log(mock_js)

                var sub_process = spawnSync('node', ['--eval', mock_js], {cwd: '/Users/glen/code/flowsheets2/build/'})
                var err = sub_process.stdout.toString();
                if (err) {
                    var error_line_number = parseInt(err.split('\n')[1].split(':')[1], 10)
                    $('.current-line-expansion').html(`<pre>Error on line ${error_line_number-1}: ${mock_js.split('\n')[error_line_number-1]}
${err}</pre>`)
                }
                console.log('error running script:', sub_process.stderr.toString())
                // if (sub_process.stdout.toString() !== 'ok') {
                //     console.log(sub_process.stderr.toString())
                // }
                var values = CircularJSON.parse(fs.readFileSync('tmp.js').toString())
                scope_values = values;

                ReactDOM.render(React.createElement(ScopeTable, {scopes: scopes, values: values}), document.querySelector('#test'))
            }

            function cursor_activity(instance) {
                // don't change sidebar if user is highlighting
                if (instance.getSelection()) {
                    return;
                }

                var line_number = instance.getCursor().line+1;
                // line change
                if (line_number !== current_line_number) {
                    current_line_number = line_number;

                    $('#sidebar #current-line h2').text('Line '+(current_line_number))
                    run_and_render();
                }

                { // show the values of the current line
                    return
                    var current_line_src = instance.getLine(current_line_number-1);
                    var current_line_ast = flow.parse(current_line_src);
                    console.log("current line's ast:", current_line_ast)
                    if (current_line_ast.body.length > 0 && current_line_ast.errors.length == 0) {
                        var html_ast = ast_to_html(current_line_ast.body[0])
                    } else {
                        var html_ast = current_line_src;
                    }

                    // write html to page
                    $('#sidebar .current-line-expansion').html('<div class="current-line">'+html_ast+'</div>')

                    if (current_line_ast.body.length > 0) {
                        $('.interpreted-line').html(evaluate_html_ast(document.querySelector('.current-line span'), scope_values))
                    } else {
                        $('.interpreted-line').html('');
                    }

                    $('.interpreted-line div').filter(function(i, el ) {
                        return el.innerText == '...'
                    }).css('opacity', 0)

                    // mouseover behavior
                    $('.interpreted-line div[data]').on('mouseenter', function(evt) {
                        var $target = $(evt.target);
                        if ($target.css('opacity') !== '0') {
                            $target.addClass('hover')
                            var $subexpression = $('.current-line span').filter(function(i, el) {
                                return $(el).text() == $target.attr('data')
                            })
                            $subexpression.addClass('hover')
                        }
                    }).on('mouseleave', function(evt) {
                        var $target = $(evt.target);
                        $target.removeClass('hover')
                        var $subexpression = $('.current-line span').filter(function(i, el) {
                            return $(el).text() == $target.attr('data')
                        })
                        $subexpression.removeClass('hover')

                    })

                    $('.current-line span').on('mouseenter', function(evt) {
                        evt.stopPropagation();
                        var $target = $(evt.target);
                        $target.addClass('hover');
                        $('.interpreted-line div[data="'+ $target.text() +'"]').addClass('hover')
                    }).on('mouseleave', function(evt) {
                        var $target = $(evt.target);
                        $target.removeClass('hover');
                        $('.interpreted-line div[data="'+ $target.text() +'"]').removeClass('hover')
                    })
                }
            }


            function ast_to_list_of_scopes(node, scope_name, current_line_number, src, output) {
                // produce a list of scopes with variable names in each scope:
                // [
                //    {name: 'file': names_in_scope: ['module', 'clamp']},
                //    {name: 'function initialize_grid() {', names_in_scope: ['width', 'height']}]
                // ]

                var scope = {name: scope_name, names_in_scope: []}

                var nodes = null;
                if (node.type == 'Program') {
                    scope.names_in_scope.push('module')
                    nodes = node.body;
                } else if (node.type == 'FunctionDeclaration' || node.type == 'FunctionExpression') {
                    node.params.forEach(param => scope.names_in_scope.push(param.name))
                    nodes = node.body.body;
                } else if (node.type == 'BlockStatement') {
                    nodes = node.body;
                } else if (node.type == 'CallExpression') {
                    nodes = node.arguments; //node.arguments[node.arguments.length-1].body;
                } else if (node.type == 'IfStatement') {
                    nodes = node.consequent.body;
                }

                if (!nodes) return output;


                // find declarations 
                nodes = nodes.filter(decl => decl.loc.start.line <= current_line_number);
                nodes.forEach(decl => {
                    switch (decl.type) {
                        case 'VariableDeclaration':
                            decl.declarations.forEach(inner_decl => {
                                scope.names_in_scope.push(inner_decl.id.name)
                            })
                            return;
                        // case 'ExpressionStatement':
                        //     return;
                        case 'ClassDeclaration':
                            scope.names_in_scope.push(decl.id.name);
                            return;
                        case 'FunctionDeclaration':
                        case 'FunctionExpression':
                            if (decl.id) {
                                scope.names_in_scope.push(decl.id.name)
                            }
                            return;
                    }
                })

                if (scope.names_in_scope.length > 0) {
                    output.push(scope);
                }

                const last_node = nodes[nodes.length-1];
                if (!last_node) return output;
                if (last_node.loc.start.line == current_line_number && last_node.loc.end.line == current_line_number) {
                    return output;
                } 

                var current_line_src = src.split('\n')[last_node.loc.start.line-1];

                if        (last_node.type == 'FunctionDeclaration' || last_node.type == 'FunctionExpression') {

                    ast_to_list_of_scopes(last_node, current_line_src, current_line_number, src, output);
                } else if (last_node.type == 'ExpressionStatement') {
                    ast_to_list_of_scopes(last_node.expression, current_line_src, current_line_number, src, output);
                } else if (last_node.type == 'CallExpression') {
                    ast_to_list_of_scopes(last_node.arguments[last_node.arguments.length-1], current_line_src, current_line_number, src, output);
                } else if (last_node.type == 'IfStatement') {
                    // find which branch of the if statement contains the current line
                    var test_node = last_node;
                    while (test_node.type == 'IfStatement') {
                        if (test_node.consequent.loc.start.line <= current_line_number && test_node.consequent.loc.end.line >= current_line_number) {
                            break
                        }
                        test_node = test_node.alternate;
                    }
                    ast_to_list_of_scopes(test_node, src.split('\n')[test_node.loc.start.line-1], current_line_number, src, output);
                } else if (last_node.type == 'FunctionExpression') {
                    ast_to_list_of_scopes(last_node.body, current_line_src, current_line_number, src, output);
                } else if (last_node.type == 'BlockStatement') {
                    ast_to_list_of_scopes(last_node.body, current_line_src, current_line_number, src, output);
                } else {
                    // console.log('error-causing node:', last_node)
                    // throw 'unhandled AST node type: '+last_node.type;
                }

                return output;
            }


            function ast_to_html(node) {
                switch (node.type) {
                    case 'IfStatement':
                        return '<span><span class="spacer">if (</span>'+ast_to_html(node.test)+') {</span>'
                    case 'BinaryExpression':
                        return '<span>' + ast_to_html(node.left) + ' <span> ' + node.operator + ' </span> ' + ast_to_html(node.right) + '</span>';
                    case 'Identifier':
                        return '<span>'+node.name+'</span>'
                    case 'Literal':
                        return `<span>${node.raw}</span>`;
                    case 'LabeledStatement':
                        return '<span>'+ node.label.name +': '+ ast_to_html(node.body) +'</span>'
                    case 'VariableDeclaration':
                        var type_str = '';
                        if (node.declarations[0].id.typeAnnotation) {
                            var range = node.declarations[0].id.typeAnnotation.typeAnnotation.range;
                            type_str = ': '+current_line.slice(range[0], range[1])
                        }
                        return `<span><span class="spacer">${node.kind} ${node.declarations[0].id.name}${type_str} = </span>${ast_to_html(node.declarations[0].init)}</span>`
                    case 'ExpressionStatement':
                        return '<span>'+ ast_to_html(node.expression) +'</span>'
                    case 'AssignmentExpression':
                        return '<span><span>'+ ast_to_html(node.left) +' '+ node.operator +'</span> '+ ast_to_html(node.right) +'</span>'
                    case 'MemberExpression':
                        return `<span><span>${node.object.name || node.object.raw || 'this'}</span>.${node.property.name}</span>`
                    case 'CallExpression':
                        return `<span><span>${ast_to_html(node.callee)}(</span>${node.arguments.map(arg_node => ast_to_html(arg_node)).join('<span>, </span>')})</span>`
                    case 'ThisExpression':
                        return `<span>this</span>`;
                    default:
                        return 'DEFAULT UH OH'
                }
            }




            function value_to_string(value) {
                if (_.isFunction(value)) {
                    return value;
                }
                if (_.isNull(value)) {
                    return 'null';
                }
                if (_.isUndefined(value)) {
                    return '...'
                }

                if (_.isObject(value)) {
                    var str = '{'
                    _.each(value, (val, key) => {
                        str += `${key}: ${val},`
                    })
                    str +=' }'
                    return str
                } else if (_.isString(value)) {
                    return `"${value}"`; 
                }
                return value
            }

            function output_html(text, width, scope) {
                try {
                    return '<div data="'+ text +'" style="width: '+ (width-2) +'px;">'+value_to_string(evalInContext(text, scope))+'</div>';
                } catch(e) {
                    return '<div data="'+ text +'" style="width: '+ (width-2) +'px;" class="spacer">...</div>'
                }

            }
            function evaluate_html_ast(node, scope) {
                // evaluates each section of a js expression with span tags around it
                if (node.children.length == 0) {
                    return output_html(node.innerText, $(node).width(), scope)
                }

                var output = '<div style="width: '+ ($(node).width()) +'px;">\n';

                output += output_html($(node).text(), $(node).width(), scope)

                output += '<div class="children" style="width: '+ ($(node).width()) +'px;">'
                for (var i = 0; i < node.children.length; ++i) {
                    var child = node.children[i];
                    output += evaluate_html_ast(child, scope)
                }
                output += '</div></div>\n'
                return output;
            }

            function ast_node_to_js(node, scopes) {
                if (!node.type) { // array of nodes
                    var nodes = node;
                    var output = '';
                    nodes.forEach(node => {
                        if (node.loc.end.line == current_line_number && node.loc.start.line == current_line_number) {
                            output += `${fs.readFileSync('/Users/glen/code/REPLugger/node_modules/circular-json/build/circular-json.js').toString()}
${scopes.map(scope => {
    return scope.names_in_scope.map(name => `replugger_values['${name}'] = ${name}`).join('\n')
}).join('\n')}
require('fs').writeFileSync('/Users/glen/code/REPLugger/tmp.js', CircularJSON.stringify(replugger_values, replugger_replacer));
`
                        }
                        output += ast_node_to_js(node, scopes)+'\n'
                    })
                    return output;
                }
                switch (node.type) {
                    case 'Program':
                        return `replugger_values = {};
replugger_replacer = function(key, value) {
    if (_.isFunction(value)) {
        return '[Function]'
    }
    return value;
}
try {
    ${ast_node_to_js(node.body, scopes)}
} catch (e) {
    console.log(e)
    ${fs.readFileSync('/Users/glen/code/REPLugger/node_modules/circular-json/build/circular-json.js').toString()}
    try {
        ${scopes.map(scope => {
            return scope.names_in_scope.map(name => `replugger_values['${name}'] = ${name}`).join('\n')
        }).join('\n')}
    } catch (e_) {}
    require('fs').writeFileSync('/Users/glen/code/REPLugger/tmp.js', CircularJSON.stringify(replugger_values, replugger_replacer));
}
process.exit();`
                    case 'ExpressionStatement':
                        if (node.loc.start.line < current_line_number && node.loc.end.line >= current_line_number) {
                            var test_node = node.expression;
                            // find the part of this expression that the cursor is in
                            while (test_node.type == 'CallExpression') {
                                test_node = test_node.arguments[test_node.arguments.length-1];
                            }
                            return `// function as argument
    ${ast_node_to_js(test_node, scopes)}`
                        }
                        return ast_node_to_js(node.expression, scopes);
                    case 'ClassDeclaration':
                        return `class ${ast_node_to_js(node.id, scopes)} ${ast_node_to_js(node.body, scopes)}`;
                    case 'ClassProperty':
                        return ``;
                    case 'MethodDefinition':
                        return `${ast_node_to_js(node.key, scopes)}(${node.value.params.map(param => param.name).join(', ')}) ${ast_node_to_js(node.value.body, scopes)}`;
                    case 'ClassBody':
                    case 'BlockStatement':
                        return `{
    ${ast_node_to_js(node.body, scopes)}
}`
                    case 'VariableDeclaration':
                        var output = ''
                        node.declarations.forEach((decl,i) => {
                            output += ast_node_to_js(decl, scopes);
                            if (i !== node.declarations.length-1) {
                                output += ',\n'
                            } else {
                                output += ';'
                            }
                        });
                        return output;
                    case 'IfStatement':
                        if (node.loc.start.line <= current_line_number && node.loc.end.line >= current_line_number) {
                            // find which branch the cursor is in
                            var test_node = node;
                            while (test_node.type == 'IfStatement') {
                                if (test_node.consequent.loc.start.line <= current_line_number && test_node.consequent.loc.end.line >= current_line_number) {
                                    break
                                }
                                test_node = test_node.alternate;
                            }
                            return `// if ${ast_node_to_js(test_node.test, scopes)}
    ${ast_node_to_js(test_node.consequent.body, scopes)}
`
                        }
                        var else_clause = '';
                        if (node.alternate) {
                            else_clause = `else ${ast_node_to_js(node.alternate, scopes)}`
                        }

                        return `if (${ast_node_to_js(node.test, scopes)}) ${ast_node_to_js(node.consequent, scopes)} ${else_clause}`;
                    case 'ConditionalExpression':
                        return `${ast_node_to_js(node.test, scopes)} ? ${ast_node_to_js(node.consequent, scopes)} : ${ast_node_to_js(node.alternate, scopes)}`
                    case 'AssignmentExpression':
                        return `${ast_node_to_js(node.left, scopes)} ${node.operator} ${ast_node_to_js(node.right, scopes)}`;
                    case 'MemberExpression':
                        if (node.computed) {
                            return `${ast_node_to_js(node.object, scopes)}[${ast_node_to_js(node.property, scopes)}]`
                        } else {
                            return `${ast_node_to_js(node.object, scopes)}.${ast_node_to_js(node.property, scopes)}`
                        }
                    case 'VariableDeclarator':
                        if (variable_overrides[current_line_number] && node.id.name in variable_overrides[current_line_number]) {
                            return `var ${node.id.name} = ${variable_overrides[current_line_number][node.id.name]}`;
                        }
                        return `var ${node.id.name} = ${ast_node_to_js(node.init, scopes)}`;
                    case 'NewExpression':
                        var arguments_str = '';
                        node.arguments.forEach((arg,i) => {
                            arguments_str += ast_node_to_js(arg, scopes)+ (i == node.arguments.length-1 ? '' : ', ');
                        })
                        return `new ${ast_node_to_js(node.callee, scopes)}(${arguments_str})`;
                    case 'CallExpression':
                        var arguments_str = '';
                        node.arguments.forEach((arg,i) => {
                            arguments_str += ast_node_to_js(arg, scopes)+ (i == node.arguments.length-1 ? '' : ', ');
                        })
                        return `${ast_node_to_js(node.callee, scopes)}(${arguments_str})`;
                    case 'FunctionExpression':
                        if (node.loc.start.line <= current_line_number && node.loc.end.line >= current_line_number) {
                            return `{
${node.params.map(param => `var ${param.name} = ${variable_overrides[current_line_number] ? variable_overrides[current_line_number][param.name] : 'null'};`).join('\n')}
${ast_node_to_js(node.body, scopes)}
}`
                        } else {
                            var params_str = '';
                            node.params.forEach((param,i) => {
                                params_str += ast_node_to_js(param, scopes)+ (i == node.params.length-1 ? '' : ', ');
                            })
                            return `${node.async ? 'async ':''} function(${params_str}) ${ast_node_to_js(node.body, scopes)}`;
                        }
                    case 'FunctionDeclaration':
                        if (node.loc.start.line <= current_line_number && node.loc.end.line >= current_line_number) {
                            return `{ // function ${ast_node_to_js(node.id, scopes)}
// first declare function ${ast_node_to_js(node.id, scopes)} so it can be called
${node.async ? 'async ':''}function ${ast_node_to_js(node.id, scopes)}(${node.params.map(param => ast_node_to_js(param, scopes).join(', '))}) ${ast_node_to_js(node.body, scopes)};
// then mock up inside of function ${ast_node_to_js(node.id, scopes)}
${node.params.map(param => `var ${param.name} = null;`).join('\n')}
${ast_node_to_js(node.body, scopes)}
}`
                        } else {
                            var params_str = '';
                            node.params.forEach((param,i) => {
                                params_str += ast_node_to_js(param, scopes)+ (i == node.params.length-1 ? '' : ', ');
                            })
                            return `${node.async ? 'async ':''}function ${ast_node_to_js(node.id, scopes)}(${params_str}) ${ast_node_to_js(node.body, scopes)}`;
                        }
                    case 'ArrowFunctionExpression':
                        return `(${node.params.map(param => ast_node_to_js(param, scopes)).join(', ')}) => ${ast_node_to_js(node.body, scopes)}`
                    case 'ForStatement':
                        return `for (${ast_node_to_js(node.init, scopes)} ${ast_node_to_js(node.test, scopes)}; ${ast_node_to_js(node.update, scopes)}) ${ast_node_to_js(node.body, scopes)}`
                    case 'ReturnStatement':
                        return `return ${node.argument ? ast_node_to_js(node.argument, scopes) : ''};`
                    case 'UnaryExpression':
                        return `${node.operator} ${ast_node_to_js(node.argument, scopes)}`
                    case 'BinaryExpression':
                    case 'LogicalExpression':
                        return `${ast_node_to_js(node.left, scopes)} ${node.operator} ${ast_node_to_js(node.right, scopes)}`;
                    case 'UpdateExpression':
                        if (node.prefix) {
                            return `${node.operator}${ast_node_to_js(node.argument, scopes)}`;
                        }
                        return `${ast_node_to_js(node.argument, scopes)}${node.operator}`;
                    case 'TryStatement':
                        return `try ${ast_node_to_js(node.block, scopes)} ${ast_node_to_js(node.handler, scopes)}`
                    case 'CatchClause':
                        return `catch(${node.param.name || ''}) ${ast_node_to_js(node.body, scopes)}`
                    case 'ArrayExpression':
                        var output = '';
                        node.elements.forEach(element => {
                            output += ast_node_to_js(element, scopes);
                            if (i !== node.declarations.length-1) {
                                output += ' ,\n'
                            }
                        })
                        return `[${output}]`
                    case 'ObjectExpression':
                        return `{${node.properties.map(prop => ast_node_to_js(prop, scopes))}}`
                    case 'Property':
                        return `${ast_node_to_js(node.key, scopes)}: ${ast_node_to_js(node.value, scopes)}`
                    case 'Identifier':
                        return node.name;
                    case 'ThisExpression':
                        return 'this';
                    case 'TemplateLiteral':
                        return '`'+ ast_node_to_js(node.quasis, scopes) + '`'
                    case 'TemplateElement':
                        return node.value.raw;
                    case 'Literal':
                        return node.raw;
                    case 'EmptyStatement':
                        return ''
                    default:
                        console.log(node)
                        return '!!!UH OH!!!'
                }
            }

            /*

                Strategy for setting up example environment:
                    find all declarations (class, function, params, variable) before the cursor / inspection point and run them.
                    anything that isn't a computed value, make up a value? e.g. 'function(evt) {', want to account for evt object.

                    run file scope ->
                        run next scope ->
                            run next scope

                    things to consider:
                        if statement (can try to automatically make the condition true)
                        for loop
                        while loop
                        case statement
                        recursion
                        class declaration should call constructor
                        function, need to create sample arguments
                        replugger(), a function that saves running state and loads it in the sidebar
                        how to handle i/o (writing to disk, network requests)

                    An interesting scenario to consider:
                        I want to scrape all the pages from the texas death row site. I want all 500 requests in memory to do computations on them.
            */


        </script>
    </body>
</html>
